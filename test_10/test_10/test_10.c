#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
//操作符详解
 

//int main()
//{
//	//  /  除号
//	//int a = 3 / 5; // 0  整数除法，得0
//	// 	printf("%d\n", a);
//	 
//	//float a = 6 / 5; //1.0
//	//printf("%f\n", a);
//
//	//float a = 6.0 / 5; //1.2  除号两端有一个数是浮点数得到的结果就是小数
//	//printf("%f\n", a);
//
//	// %取余 7%3即7除3之后的余数
//	//int a = 7 % 3; // 1
//	//printf("%d\n", a);
//	 //!!!操作符 % 两端必须为整数
//	return 0;
//}


////移位操作符 <<  >>
//
////对于移位运算符，不要移动负数位，这个标准是未定义的
////int a=1
////int b=a<<-2 ×不可以移动负数位
//int main()
//{
//	//int a = 2;
//	//int b = a << 1;
//	////把a的二进制位向左移动1位
//	////a为int 型，内存中占32个比特位，则a的二进制编码为 0000000000000000000000000000010
//	////                        a的二进制位向左移动1位 0 0000000000000000000000000000100  十进制即为 0*2的0次方+0*2的1次方+1*2的2次方=4
//	////左移操作符：左边丢弃，右边补0
//	//printf("b=%d\n", b);
//
//	//右移操作符
//	//把a的二进制位向右移动1位
//	//1・算数右移 右边丢弃，左边补原符号位
//	//2・逻辑右移 右边丢弃，左边补0
//	
//	int a = -1;
//	int b = a >> 1;
//
//	printf( "%d\n",b );
//	//负数-1  负数存放在内存中
//	//	存放的是二进制的补码
//	// 正整数的原码，补码，反码相同
//	//原码：10000000000000000000000000000001
//	//反码：11111111111111111111111111111110
//	//补码：11111111111111111111111111111111
//
//	//整数的二进制表示形式：其实有三种（对于负数）
//	//1・原码 直接根据数值写出的二进制序列就是原码
//	//2・反码 原码的符号位不变，其他位按位取反
//	//3・补码 反码+1，就是补码
//	return 0;
//}


//位操作符 & | ^
//int main()
//{
//	//int a = 3;
//	//int b = 5;
//	//// ^ - 按（2进制）位异或
//	////对应而二进制位进行异或
//	////规则：相同为0，相异为1
// //  int c = a ^ b;
// //  printf("c=%d\n", c);
// //  //00000000000000000000000000000011 表示3
// //  //00000000000000000000000000000101 表示5
// //  //00000000000000000000000000000110
//	// 
//
//	//// | - 按（2进制）位或
//	//int c = a | b;
//	//printf("c=%d\n", c);
//	////00000000000000000000000000000011 表示3
//	////00000000000000000000000000000101 表示5
//	////相同位按位与，只要有1就为1，两个都是0才是0
//	////00000000000000000000000000000111
//
//	//// & - 按（2进制）位与
//	//int c = a&b;
//	//printf("c=%d\n", c);
//	////00000000000000000000000000000011 表示3
//	////00000000000000000000000000000101 表示5
//	////相同位按位与，只要有0就为0，两个都是1才是1
//    ////00000000000000000000000000000001
//
//	return 0;
//}
 


////a=3,b=5，交换a，b的值不允许使用第三个变量
//int main()
//{
//	int a = 3;
//	int b = 5;
//	//交换
//	printf("a=%d b=%d\n", a, b);
//	a = a + b;
//	b = a - b;
//	a = a - b;
//	printf("a=%d b=%d\n", a, b);
//
//	return 0;
//}//这种方法如果a，b的值很大，a+b的值超出了整形存储的内存，会溢出

//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("a=%d b=%d\n", a, b);
//	a = a ^ b;
//	b = b ^ a;
//	a = a ^ b;
//	printf("a=%d b=%d\n", a, b);
//	return 0;
//}

//单目操作符
//只有一个操作数的操作符

//// ！ 把真变成假，假变成真
//int main()
//{
//	int flag = 5;
//	//flag为真，打印hehe
//	if (flag)
//	{
//		printf("hehe\n");
//	}
//	//flag为假，打印haha
//	if (!flag)
//	{
//		printf("haha\n");
//	}
//	return 0;
//}

// - 变负


//sizeof 计算和统计类型的长度
//char arr[10]={0};  sizeof(a)计算a所占的空间大小，单位是字节
//sizeof（）括号中如果有表达式，其不参与后面的计算

// ~ 对一个数的二进制按位取反

// ++ 后置++，先使用再++ 。前置++，先++再使用
// -- 与++同理

//// & 取地址
////*
//int main()
//{
//	int a = 10;
//	printf("%p\n", &a);//& -取地址操作符
//	int* pa = &a;//pa是用来存放地址的 - pa就是一个指针变量
//	*pa=20;//* - 解引用操作符 - 间接访问操作符
//	printf("%d\n", a);//20
//	return 0;
//}

//// (类型) - 强制类型转换
//int main()
//{
//	int a = (int)3.14;(a的类型强制转换为int)
//	return 0;
//}

//关系操作符
// <  <=  >  >=  !=  ==

//逻辑操作符
// && 逻辑与  ||逻辑或

//条件操作符
// cxp1？exp2：exp3
//b = a > 5 ? 1 : -1; //a是否大于5，a大于5则1赋值给a否则赋值-1


//逗号表达式
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = 0;
//	//逗号表达式 - 要从左向右依次计算，但是整个表达式的结果是最后一个表达式的结果
//
//	int d = (c = 5, a = c + 3, b = a - 4, c += 5);
//	printf("%d\n", d);//即为c+=5的值
//	return 0;
//}


//下标引用，函数调用和结构成员

//1・下标引用操作符[]
//操作数：一个数组名+一个索引值
//arr[9]  []的两个操作数是arr和9

//2・函数调用操作符
// 
//函数的定义
//int Add(int x, int y)
//{
//	return x + y;
//}
//void test()
//{}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//函数调用
//	int ret = Add(a, b);// () - 函数调用操作符
//	test();
//
//	return 0;
//}

////3・访问一个结构的成员
//// .
//// ->
//
////结构体
//// int char float short long double
////
////书：书名，书号，定价
////人：名字，年龄，性别
////
//
//
////创建了一个自定义类型
//struct Book //struct是一种语法形式，定义一种新的类型
//{
//	//结构体的成员变量
//	char name[20];
//	char id[20];
//	int price;
//};//{}描述相关属性， ；最后的；不可缺少
//int main()
//{
//	//int num = 10;
//	//结构体变量名.成员名
//	struct Book b= {"C语言","C20230731",55};
//	struct Book* pb = &b;
//
//	//结构体指针->成员名
//	printf("书名：%s\n", pb->name);
//	printf("书号：%s\n", pb->id);
//	printf("价格：%d\n", pb->price);
//
//	/*printf("书名：%s\n", (*pb).name);
//	printf("书号：%s\n", (*pb).id);
//	printf("价格：%d\n", (*pb).price);*/
//
//	/*printf("书名：%s\n", b.name);
//	printf("书号：%s\n", b.id);
//	printf("价格：%d\n", b.price);*/
//
//	return 0;
//}


////整形提升
// 
// 
//int main()
//{
//	char a = 3;
//	//00000000000000000000000000000011
//	//00000011   char只占8个bit位截断则a的二进制位就是这
//	char b = 127;
//	//00000000000000000000000001111111
//	//01111111
//	char c = a + b;
//
//	//这里发现a和b都是char类型的，都没有达到一个int的大小
//	//这里就会发生整形提升
//	// 
//	//整形提升是按照变量的数据类型的符号位来提升的
//
//	//00000011 -a   符号位是0
//	//a整形提升   
//	//b同理   如果为负数（符号位为1）则整形提升前面全补1
//	//无符号的类型进行整形提示，高位统一都是补0
//
//	//则提升后
//	//a 00000000000000000000000000000011
//	//b 00000000000000000000000001111111
//	//则c=a+b=00000000000000000000000010000010
//	//c为char类型只能放8个bit为位则10000010
//
//	printf("%d\n", c);
//	//c打印%d为整形，而c为char类型，打印也要进行整形提升
//	//c为10000010，提升后11111111111111111111111110000010
//	//为负数在内存里存放的是补码
//	//其原码为1000000000000000000000011111110为-126
//
//	return 0;
//}


//算数转换
//如果某个操作符的各个操作数属于不同类型，那么除非其中一个操作数转换为另一个操作数的类型，否则操作无法进行下去
// long double
// double
// float
// unsigned long int
// long int
// int
//自下而上进行转换  例如int和float类型在一起，int转换为float进行运输

